{"ast":null,"code":"import { useState, useCallback, useEffect, useMemo, useDebugValue } from 'react';\nimport { a as useNow, u as useUtils } from './useUtils-e7fee764.js';\nimport _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';\n\nfunction useOpenState(_ref) {\n  var open = _ref.open,\n      onOpen = _ref.onOpen,\n      onClose = _ref.onClose;\n  var setIsOpenState = null;\n\n  if (open === undefined || open === null) {\n    // The component is uncontrolled, so we need to give it its own state.\n    var _useState = useState(false);\n\n    var _useState2 = _slicedToArray(_useState, 2);\n\n    open = _useState2[0];\n    setIsOpenState = _useState2[1];\n  } // prettier-ignore\n\n\n  var setIsOpen = useCallback(function (newIsOpen) {\n    setIsOpenState && setIsOpenState(newIsOpen);\n    return newIsOpen ? onOpen && onOpen() : onClose && onClose();\n  }, [onOpen, onClose, setIsOpenState]);\n  return {\n    isOpen: open,\n    setIsOpen: setIsOpen\n  };\n}\n\nvar FORCE_FINISH_PICKER = Symbol('Force closing picker, used for accessibility ');\n\nfunction usePickerState(props, parseInputValue, validateInputValue) {\n  var autoOk = props.autoOk,\n      inputFormat = props.inputFormat,\n      disabled = props.disabled,\n      readOnly = props.readOnly,\n      onAccept = props.onAccept,\n      onChange = props.onChange,\n      onError = props.onError,\n      value = props.value;\n\n  if (!inputFormat) {\n    throw new Error('inputFormat prop is required');\n  }\n\n  var now = useNow();\n  var utils = useUtils();\n  var date = parseInputValue(now, utils, props);\n\n  var _useState = useState(date),\n      _useState2 = _slicedToArray(_useState, 2),\n      pickerDate = _useState2[0],\n      setPickerDate = _useState2[1]; // Mobile keyboard view is a special case.\n  // When it's open picker should work like closed, cause we are just showing text field\n\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isMobileKeyboardViewOpen = _useState4[0],\n      setMobileKeyboardViewOpen = _useState4[1];\n\n  var _useOpenState = useOpenState(props),\n      isOpen = _useOpenState.isOpen,\n      setIsOpen = _useOpenState.setIsOpen;\n\n  useEffect(function () {\n    // if value was changed in closed state or from mobile keyboard view - treat it as accepted\n    if ((!isOpen || isMobileKeyboardViewOpen) && !utils.isEqual(pickerDate, date)) {\n      setPickerDate(date);\n    }\n  }, [date, isMobileKeyboardViewOpen, isOpen, pickerDate, utils]);\n  var acceptDate = useCallback(function (acceptedDate, needClosePicker) {\n    onChange(acceptedDate);\n\n    if (needClosePicker) {\n      setIsOpen(false);\n\n      if (onAccept) {\n        onAccept(acceptedDate);\n      }\n    }\n  }, [onAccept, onChange, setIsOpen]);\n  var wrapperProps = useMemo(function () {\n    return {\n      open: isOpen,\n      format: inputFormat,\n      onClear: function onClear() {\n        return acceptDate(null, true);\n      },\n      onAccept: function onAccept() {\n        return acceptDate(pickerDate, true);\n      },\n      onDismiss: function onDismiss() {\n        return setIsOpen(false);\n      },\n      onSetToday: function onSetToday() {\n        // TODO FIX ME\n        setPickerDate(now);\n        acceptDate(now, Boolean(autoOk));\n      }\n    };\n  }, [acceptDate, autoOk, inputFormat, isOpen, now, pickerDate, setIsOpen]);\n  var pickerProps = useMemo(function () {\n    return {\n      date: pickerDate,\n      isMobileKeyboardViewOpen: isMobileKeyboardViewOpen,\n      toggleMobileKeyboardView: function toggleMobileKeyboardView() {\n        if (!isMobileKeyboardViewOpen) {\n          // accept any partial input done by user\n          setPickerDate(pickerDate);\n        }\n\n        setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen);\n      },\n      onDateChange: function onDateChange(newDate, currentVariant) {\n        var isFinish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        setPickerDate(newDate);\n        var isFinishing = typeof isFinish === 'boolean' ? isFinish : isFinish === FORCE_FINISH_PICKER;\n\n        if (isFinishing) {\n          var autoAcceptRequested = Boolean(autoOk) || isFinish === FORCE_FINISH_PICKER;\n\n          if (currentVariant === 'mobile' && autoAcceptRequested) {\n            acceptDate(newDate, true);\n          }\n\n          if (currentVariant !== 'mobile') {\n            acceptDate(newDate, autoAcceptRequested);\n          }\n        }\n      }\n    };\n  }, [acceptDate, autoOk, isMobileKeyboardViewOpen, pickerDate]);\n  var validationError = validateInputValue(value, utils, props);\n  useEffect(function () {\n    if (onError) {\n      onError(validationError, value);\n    }\n  }, [onError, validationError, value]);\n  var inputProps = useMemo(function () {\n    return {\n      onChange: onChange,\n      inputFormat: inputFormat,\n      rawValue: value,\n      validationError: validationError,\n      openPicker: function openPicker() {\n        return !readOnly && !disabled && setIsOpen(true);\n      }\n    };\n  }, [disabled, inputFormat, onChange, readOnly, setIsOpen, validationError, value]);\n  var pickerState = {\n    pickerProps: pickerProps,\n    inputProps: inputProps,\n    wrapperProps: wrapperProps\n  };\n  useDebugValue(pickerState, function () {\n    return {\n      MuiPickerState: {\n        pickerDate: pickerDate,\n        parsedDate: date,\n        other: pickerState\n      }\n    };\n  });\n  return pickerState;\n}\n\nexport { FORCE_FINISH_PICKER as F, usePickerState as u };","map":{"version":3,"sources":["../src/_shared/hooks/useOpenState.ts","../src/_shared/hooks/usePickerState.ts"],"names":["open","onOpen","onClose","setIsOpenState","useState","setIsOpen","useCallback","newIsOpen","isOpen","FORCE_FINISH_PICKER","Symbol","autoOk","inputFormat","disabled","readOnly","onAccept","onChange","onError","value","props","now","useNow","utils","useUtils","date","parseInputValue","pickerDate","setPickerDate","isMobileKeyboardViewOpen","setMobileKeyboardViewOpen","useOpenState","useEffect","acceptDate","wrapperProps","useMemo","format","onClear","onDismiss","onSetToday","Boolean","pickerProps","toggleMobileKeyboardView","onDateChange","isFinish","isFinishing","autoAcceptRequested","currentVariant","validationError","validateInputValue","inputProps","rawValue","openPicker","pickerState","useDebugValue","MuiPickerState","parsedDate","other"],"mappings":";;;;AAIO,SAAA,YAAA,CAAA,IAAA,EAA4E;MAApDA,IAAoD,GAAA,IAAA,CAApDA,I;MAAMC,MAA8C,GAAA,IAAA,CAA9CA,M;MAAQC,OAAsC,GAAA,IAAA,CAAtCA,O;MACvCC,cAAwD,GAA5D,I;;MACIH,IAAI,KAAJA,SAAAA,IAAsBA,IAAI,KAA9B,I,EAAyC;;oBAEdI,QAAQ,CAFM,KAEN,C;;;;AAAhCJ,IAAAA,IAFsC,GAAA,UAAA,CAAA,CAAA,CAEtCA;AAAMG,IAAAA,cAFgC,GAAA,UAAA,CAAA,CAAA,CAEhCA;AAJwE,GAAA,CAAA;;;MAQ3EE,SAAS,GAAGC,WAAW,CAAC,UAAA,SAAA,EAAwB;AACpDH,IAAAA,cAAc,IAAIA,cAAc,CAAhCA,SAAgC,CAAhCA;WAEOI,SAAS,GACZN,MAAM,IAAIA,MADE,EAAA,GAEZC,OAAO,IAAIA,OAFf,E;AAH2B,GAAA,EAM1B,CAAA,MAAA,EAAA,OAAA,EANH,cAMG,CAN0B,C;SAQtB;AAAEM,IAAAA,MAAM,EAAR,IAAA;AAAgBH,IAAAA,SAAS,EAATA;AAAhB,G;;;ICbII,mBAAmB,GAAGC,MAAM,CAAlC,+CAAkC,C;;AAElC,SAAA,cAAA,CAAA,KAAA,EAAA,eAAA,EAAA,kBAAA,EAYL;MACQC,MADR,GACwFQ,KADxF,CAAA,M;MACgBP,WADhB,GACwFO,KADxF,CAAA,W;MAC6BN,QAD7B,GACwFM,KADxF,CAAA,Q;MACuCL,QADvC,GACwFK,KADxF,CAAA,Q;MACiDJ,QADjD,GACwFI,KADxF,CAAA,Q;MAC2DH,QAD3D,GACwFG,KADxF,CAAA,Q;MACqEF,OADrE,GACwFE,KADxF,CAAA,O;MAC8ED,KAD9E,GACwFC,KADxF,CAAA,K;;MAGI,CAAJ,W,EAAkB;UACV,IAAA,KAAA,CAAN,8BAAM,C;;;MAGFC,GAAG,GAAGC,MAAZ,E;MACMC,KAAK,GAAGC,QAAd,E;MACMC,IAAI,GAAGC,eAAe,CAAA,GAAA,EAAA,KAAA,EAA5B,KAA4B,C;;kBACQrB,QAAQ,CAV5C,IAU4C,C;;MAArCsB,UAVP,GAAA,UAAA,CAAA,CAAA,C;MAUmBC,aAVnB,GAAA,UAAA,CAAA,CAAA,C,CAAA,CAAA;;;;mBAc8DvB,QAAQ,CAdtE,KAcsE,C;;MAA/DwB,wBAdP,GAAA,UAAA,CAAA,CAAA,C;MAciCC,yBAdjC,GAAA,UAAA,CAAA,CAAA,C;;sBAe8BC,YAAY,CAf1C,KAe0C,C;MAAlCtB,MAfR,GAAA,aAAA,CAAA,M;MAegBH,SAfhB,GAAA,aAAA,CAAA,S;;AAiBA0B,EAAAA,SAAS,CAAC,YAAM;;QAEV,CAAC,CAAA,MAAA,IAAD,wBAAA,KAAyC,CAACT,KAAK,CAALA,OAAAA,CAAAA,UAAAA,EAA9C,IAA8CA,C,EAAiC;AAC7EK,MAAAA,aAAa,CAAbA,IAAa,CAAbA;;AAHK,GAAA,EAKN,CAAA,IAAA,EAAA,wBAAA,EAAA,MAAA,EAAA,UAAA,EALHI,KAKG,CALM,CAATA;MAOMC,UAAU,GAAG1B,WAAW,CAC5B,UAAA,YAAA,EAAA,eAAA,EAA4D;AAC1DU,IAAAA,QAAQ,CAARA,YAAQ,CAARA;;QAEA,e,EAAqB;AACnBX,MAAAA,SAAS,CAATA,KAAS,CAATA;;UAEA,Q,EAAc;AACZU,QAAAA,QAAQ,CAARA,YAAQ,CAARA;;;AARsB,GAAA,EAY5B,CAAA,QAAA,EAAA,QAAA,EAZF,SAYE,CAZ4B,C;MAexBkB,YAAY,GAAGC,OAAO,CAC1B,YAAA;WAAO;AACLlC,MAAAA,IAAI,EADC,MAAA;AAELmC,MAAAA,MAAM,EAFD,WAAA;AAGLC,MAAAA,OAAO,EAAE,SAAA,OAAA,GAAA;eAAMJ,UAAU,CAAA,IAAA,EAAhB,IAAgB,C;AAHpB,OAAA;AAILjB,MAAAA,QAAQ,EAAE,SAAA,QAAA,GAAA;eAAMiB,UAAU,CAAA,UAAA,EAAhB,IAAgB,C;AAJrB,OAAA;AAKLK,MAAAA,SAAS,EAAE,SAAA,SAAA,GAAA;eAAMhC,SAAS,CAAf,KAAe,C;AALrB,OAAA;AAMLiC,MAAAA,UAAU,EAAE,SAAA,UAAA,GAAM;;AAEhBX,QAAAA,aAAa,CAAbA,GAAa,CAAbA;AACAK,QAAAA,UAAU,CAAA,GAAA,EAAaO,OAAO,CAA9BP,MAA8B,CAApB,CAAVA;;AATG,K;AADmB,GAAA,EAa1B,CAAA,UAAA,EAAA,MAAA,EAAA,WAAA,EAAA,MAAA,EAAA,GAAA,EAAA,UAAA,EAbF,SAaE,CAb0B,C;MAgBtBQ,WAAW,GAAGN,OAAO,CACzB,YAAA;WAAO;AACLV,MAAAA,IAAI,EADC,UAAA;AAELI,MAAAA,wBAAwB,EAFnB,wBAAA;AAGLa,MAAAA,wBAAwB,EAAE,SAAA,wBAAA,GAAM;YAC1B,CAAJ,wB,EAA+B;;AAE7Bd,UAAAA,aAAa,CAAbA,UAAa,CAAbA;;;AAGFE,QAAAA,yBAAyB,CAAC,CAA1BA,wBAAyB,CAAzBA;AATG,OAAA;AAWLa,MAAAA,YAAY,EAAE,SAAA,YAAA,CAAA,OAAA,EAAA,cAAA,EAIT;YADHC,QACG,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD0B,I;AAE7BhB,QAAAA,aAAa,CAAbA,OAAa,CAAbA;YACMiB,WAAW,GACf,OAAA,QAAA,KAAA,SAAA,GAAA,QAAA,GAA2CD,QAAQ,KADrD,mB;;YAGA,W,EAAiB;cACTE,mBAAmB,GAAGN,OAAO,CAAPA,MAAO,CAAPA,IAAmBI,QAAQ,KAAvD,mB;;cACIG,cAAc,KAAdA,QAAAA,IAAJ,mB,EAAwD;AACtDd,YAAAA,UAAU,CAAA,OAAA,EAAVA,IAAU,CAAVA;;;cAGEc,cAAc,KAAlB,Q,EAAiC;AAC/Bd,YAAAA,UAAU,CAAA,OAAA,EAAVA,mBAAU,CAAVA;;;;AA3BD,K;AADkB,GAAA,EAiCzB,CAAA,UAAA,EAAA,MAAA,EAAA,wBAAA,EAjCF,UAiCE,CAjCyB,C;MAoCrBe,eAAe,GAAGC,kBAAkB,CAAA,KAAA,EAAA,KAAA,EAA1C,KAA0C,C;AAC1CjB,EAAAA,SAAS,CAAC,YAAM;QACd,O,EAAa;AACXd,MAAAA,OAAO,CAAA,eAAA,EAAPA,KAAO,CAAPA;;AAFK,GAAA,EAIN,CAAA,OAAA,EAAA,eAAA,EAJHc,KAIG,CAJM,CAATA;MAMMkB,UAAU,GAAGf,OAAO,CACxB,YAAA;WAAO;AACLlB,MAAAA,QAAQ,EADH,QAAA;AAELJ,MAAAA,WAAW,EAFN,WAAA;AAGLsC,MAAAA,QAAQ,EAHH,KAAA;AAILH,MAAAA,eAAe,EAJV,eAAA;AAKLI,MAAAA,UAAU,EAAE,SAAA,UAAA,GAAA;eAAM,CAAA,QAAA,IAAa,CAAb,QAAA,IAA0B9C,SAAS,CAAzC,IAAyC,C;;AALhD,K;AADiB,GAAA,EAQxB,CAAA,QAAA,EAAA,WAAA,EAAA,QAAA,EAAA,QAAA,EAAA,SAAA,EAAA,eAAA,EARF,KAQE,CARwB,C;MAWpB+C,WAAW,GAAG;AAAEZ,IAAAA,WAAW,EAAb,WAAA;AAAeS,IAAAA,UAAU,EAAzB,UAAA;AAA2BhB,IAAAA,YAAY,EAAZA;AAA3B,G;AACpBoB,EAAAA,aAAa,CAAA,WAAA,EAAc,YAAA;WAAO;AAChCC,MAAAA,cAAc,EAAE;AACd5B,QAAAA,UAAU,EADI,UAAA;AAEd6B,QAAAA,UAAU,EAFI,IAAA;AAGdC,QAAAA,KAAK,EAAEJ;AAHO;AADgB,K;AAAlCC,GAAa,CAAbA;SAQA,W","sourcesContent":["/* eslint-disable react-hooks/rules-of-hooks */\nimport { BasePickerProps } from '../../typings/BasePicker';\nimport { useCallback, useState, Dispatch, SetStateAction } from 'react';\n\nexport function useOpenState({ open, onOpen, onClose }: BasePickerProps<any, any>) {\n  let setIsOpenState: null | Dispatch<SetStateAction<boolean>> = null;\n  if (open === undefined || open === null) {\n    // The component is uncontrolled, so we need to give it its own state.\n    [open, setIsOpenState] = useState<boolean>(false);\n  }\n\n  // prettier-ignore\n  const setIsOpen = useCallback((newIsOpen: boolean) => {\n    setIsOpenState && setIsOpenState(newIsOpen);\n\n    return newIsOpen\n      ? onOpen && onOpen()\n      : onClose && onClose();\n  }, [onOpen, onClose, setIsOpenState]);\n\n  return { isOpen: open, setIsOpen };\n}\n","import { useOpenState } from './useOpenState';\nimport { WrapperVariant } from '../../wrappers/Wrapper';\nimport { BasePickerProps } from '../../typings/BasePicker';\nimport { MaterialUiPickersDate } from '../../typings/date';\nimport { useUtils, useNow, MuiPickersAdapter } from './useUtils';\nimport { useCallback, useDebugValue, useEffect, useMemo, useState } from 'react';\n\nexport const FORCE_FINISH_PICKER = Symbol('Force closing picker, used for accessibility ');\n\nexport function usePickerState<TInput, TOutput>(\n  props: BasePickerProps<TInput, TOutput>,\n  parseInputValue: (\n    now: MaterialUiPickersDate,\n    utils: MuiPickersAdapter,\n    props: BasePickerProps<TInput, TOutput>\n  ) => TOutput | null,\n  validateInputValue: (\n    value: TInput,\n    utils: MuiPickersAdapter,\n    props: BasePickerProps<TInput, TOutput>\n  ) => React.ReactNode | undefined\n) {\n  const { autoOk, inputFormat, disabled, readOnly, onAccept, onChange, onError, value } = props;\n\n  if (!inputFormat) {\n    throw new Error('inputFormat prop is required');\n  }\n\n  const now = useNow();\n  const utils = useUtils();\n  const date = parseInputValue(now, utils, props);\n  const [pickerDate, setPickerDate] = useState(date);\n\n  // Mobile keyboard view is a special case.\n  // When it's open picker should work like closed, cause we are just showing text field\n  const [isMobileKeyboardViewOpen, setMobileKeyboardViewOpen] = useState(false);\n  const { isOpen, setIsOpen } = useOpenState(props);\n\n  useEffect(() => {\n    // if value was changed in closed state or from mobile keyboard view - treat it as accepted\n    if ((!isOpen || isMobileKeyboardViewOpen) && !utils.isEqual(pickerDate, date)) {\n      setPickerDate(date);\n    }\n  }, [date, isMobileKeyboardViewOpen, isOpen, pickerDate, utils]);\n\n  const acceptDate = useCallback(\n    (acceptedDate: TOutput | null, needClosePicker: boolean) => {\n      onChange(acceptedDate);\n\n      if (needClosePicker) {\n        setIsOpen(false);\n\n        if (onAccept) {\n          onAccept(acceptedDate);\n        }\n      }\n    },\n    [onAccept, onChange, setIsOpen]\n  );\n\n  const wrapperProps = useMemo(\n    () => ({\n      open: isOpen,\n      format: inputFormat,\n      onClear: () => acceptDate(null, true),\n      onAccept: () => acceptDate(pickerDate, true),\n      onDismiss: () => setIsOpen(false),\n      onSetToday: () => {\n        // TODO FIX ME\n        setPickerDate(now as any);\n        acceptDate(now as any, Boolean(autoOk));\n      },\n    }),\n    [acceptDate, autoOk, inputFormat, isOpen, now, pickerDate, setIsOpen]\n  );\n\n  const pickerProps = useMemo(\n    () => ({\n      date: pickerDate,\n      isMobileKeyboardViewOpen,\n      toggleMobileKeyboardView: () => {\n        if (!isMobileKeyboardViewOpen) {\n          // accept any partial input done by user\n          setPickerDate(pickerDate);\n        }\n\n        setMobileKeyboardViewOpen(!isMobileKeyboardViewOpen);\n      },\n      onDateChange: (\n        newDate: TOutput,\n        currentVariant: WrapperVariant,\n        isFinish: boolean | symbol = true\n      ) => {\n        setPickerDate(newDate);\n        const isFinishing =\n          typeof isFinish === 'boolean' ? isFinish : isFinish === FORCE_FINISH_PICKER;\n\n        if (isFinishing) {\n          const autoAcceptRequested = Boolean(autoOk) || isFinish === FORCE_FINISH_PICKER;\n          if (currentVariant === 'mobile' && autoAcceptRequested) {\n            acceptDate(newDate, true);\n          }\n\n          if (currentVariant !== 'mobile') {\n            acceptDate(newDate, autoAcceptRequested);\n          }\n        }\n      },\n    }),\n    [acceptDate, autoOk, isMobileKeyboardViewOpen, pickerDate]\n  );\n\n  const validationError = validateInputValue(value, utils, props);\n  useEffect(() => {\n    if (onError) {\n      onError(validationError, value);\n    }\n  }, [onError, validationError, value]);\n\n  const inputProps = useMemo(\n    () => ({\n      onChange,\n      inputFormat,\n      rawValue: value,\n      validationError,\n      openPicker: () => !readOnly && !disabled && setIsOpen(true),\n    }),\n    [disabled, inputFormat, onChange, readOnly, setIsOpen, validationError, value]\n  );\n\n  const pickerState = { pickerProps, inputProps, wrapperProps };\n  useDebugValue(pickerState, () => ({\n    MuiPickerState: {\n      pickerDate,\n      parsedDate: date,\n      other: pickerState,\n    },\n  }));\n\n  return pickerState;\n}\n"]},"metadata":{},"sourceType":"module"}