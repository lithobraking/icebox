{"ast":null,"code":"import { useCallback, useContext, createContext, useState, useEffect } from 'react';\nimport _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';\nimport _typeof from '@babel/runtime/helpers/esm/typeof';\n/* Use it instead of .includes method for IE support */\n\nfunction arrayIncludes(array, itemOrItems) {\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.every(function (item) {\n      return array.indexOf(item) !== -1;\n    });\n  }\n\n  return array.indexOf(itemOrItems) !== -1;\n}\n\nvar onSpaceOrEnter = function onSpaceOrEnter(innerFn, onFocus) {\n  return function (event) {\n    if (event.key === 'Enter' || event.key === ' ') {\n      innerFn(); // prevent any side effects\n\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n};\n/* Quick untyped helper to improve function composition readability */\n\n\nvar pipe = function pipe() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return fns.reduceRight(function (prevFn, nextFn) {\n    return function () {\n      return nextFn(prevFn.apply(void 0, arguments));\n    };\n  }, function (value) {\n    return value;\n  });\n};\n\nvar executeInTheNextEventLoopTick = function executeInTheNextEventLoopTick(fn) {\n  setTimeout(fn, 0);\n};\n\nfunction createDelegatedEventHandler(fn, onEvent) {\n  return function (event) {\n    fn(event);\n\n    if (onEvent) {\n      onEvent(event);\n    }\n  };\n}\n\nfunction mergeRefs(refs) {\n  return function (value) {\n    refs.forEach(function (ref) {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (_typeof(ref) === 'object' && ref != null) {\n        // @ts-ignore .current is not a readonly, hold on ts\n        ref.current = value;\n      }\n    });\n  };\n}\n\nvar CanAutoFocusContext = createContext(true);\n\nvar useCanAutoFocus = function useCanAutoFocus() {\n  return useContext(CanAutoFocusContext);\n};\n\nfunction useAutoFocusControl(open) {\n  var _React$useState = useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      canAutoFocus = _React$useState2[0],\n      setCanAutoFocus = _React$useState2[1];\n\n  useEffect(function () {\n    if (!open) {\n      setCanAutoFocus(false);\n    }\n  }, [open]);\n  return {\n    canAutoFocus: canAutoFocus,\n    onOpen: useCallback(function () {\n      return setCanAutoFocus(true);\n    }, [])\n  };\n}\n\nexport { CanAutoFocusContext as C, arrayIncludes as a, useAutoFocusControl as b, createDelegatedEventHandler as c, executeInTheNextEventLoopTick as e, mergeRefs as m, onSpaceOrEnter as o, pipe as p, useCanAutoFocus as u };","map":{"version":3,"sources":["../src/_helpers/utils.ts","../src/_shared/hooks/useCanAutoFocus.tsx"],"names":["Array","array","onSpaceOrEnter","event","innerFn","onFocus","pipe","fns","nextFn","prevFn","executeInTheNextEventLoopTick","setTimeout","fn","onEvent","refs","ref","CanAutoFocusContext","React","useCanAutoFocus","canAutoFocus","setCanAutoFocus","onOpen"],"mappings":"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","sourcesContent":["import * as React from 'react';\n\n/* Use it instead of .includes method for IE support */\nexport function arrayIncludes<T>(array: T[] | readonly T[], itemOrItems: T | T[]) {\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.every((item) => array.indexOf(item) !== -1);\n  }\n\n  return array.indexOf(itemOrItems) !== -1;\n}\n\nexport const onSpaceOrEnter = (\n  innerFn: () => void,\n  onFocus?: (event: React.KeyboardEvent<any>) => void\n) => (event: React.KeyboardEvent) => {\n  if (event.key === 'Enter' || event.key === ' ') {\n    innerFn();\n\n    // prevent any side effects\n    event.preventDefault();\n    event.stopPropagation();\n  }\n\n  if (onFocus) {\n    onFocus(event);\n  }\n};\n\n/* Quick untyped helper to improve function composition readability */\nexport const pipe = (...fns: ((...args: any[]) => any)[]) =>\n  fns.reduceRight(\n    (prevFn, nextFn) => (...args) => nextFn(prevFn(...args)),\n    (value) => value\n  );\n\nexport const executeInTheNextEventLoopTick = (fn: () => void) => {\n  setTimeout(fn, 0);\n};\n\nexport function createDelegatedEventHandler<TEvent>(\n  fn: (event: TEvent) => void,\n  onEvent?: (event: TEvent) => void\n) {\n  return (event: TEvent) => {\n    fn(event);\n\n    if (onEvent) {\n      onEvent(event);\n    }\n  };\n}\n\nexport function mergeRefs<T>(refs: (React.Ref<T | null> | undefined)[]) {\n  return (value: T) => {\n    refs.forEach((ref) => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (typeof ref === 'object' && ref != null) {\n        // @ts-ignore .current is not a readonly, hold on ts\n        ref.current = value;\n      }\n    });\n  };\n}\n","import * as React from 'react';\n\nexport const CanAutoFocusContext = React.createContext(true);\n\nexport const useCanAutoFocus = () => React.useContext(CanAutoFocusContext);\n\nexport function useAutoFocusControl(open: boolean) {\n  const [canAutoFocus, setCanAutoFocus] = React.useState(false);\n\n  React.useEffect(() => {\n    if (!open) {\n      setCanAutoFocus(false);\n    }\n  }, [open]);\n\n  return {\n    canAutoFocus,\n    onOpen: React.useCallback(() => setCanAutoFocus(true), []),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}